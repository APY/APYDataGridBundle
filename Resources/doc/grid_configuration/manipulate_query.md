Manipulating the query builder
============================

The Entity Source provides two ways of manipulating the query which is used for generating the grid - 

1. (Recommended) Using a callback method to modify the query that was generated by the grid
2. (Advanced) Injecting a custom QueryBuilder object which then will be used and expanded by the grid

## 1. Using a callback
This is the recommended way of modifying the query because the query is still created by the grid and therefore we can ensure its integrity. 
This method should be sufficient for virtual every use-case.

```php
<?php
...
$source->manipulateQuery($callback);

$grid->setSource($source);
...
```

### Method Source::manipulateQuery parameters

|parameter|Type|Default value|Description|
|:--:|:--|:--|:--|:--|
|callback|[\Closure](http://php.net/manual/en/functions.anonymous.php) or [callable](http://php.net/manual/en/language.types.callable.php)|null|Callback to manipulate the query. Null means no callback.|

### Callback parameters

|parameter|Type|Description|
|:--:|:--|:--|:--|:--|
|query|instance of QueryBuilder|The QueryBuilder instance before its execution|

### Examples

```php
<?php
...
$source->manipulateQuery(
    function ($query)
    {
        $query->resetDQLPart('orderBy');
    }
);

$grid->setSource($source);
...
```

If you want to pass some context parameters:

```php
<?php
...
$tableAlias = $source->getTableAlias();

$source->manipulateQuery(
    function ($query) use ($tableAlias)
    {
        $query->andWhere($tableAlias . '.active = 1');
    }
);

$grid->setSource($source);
...
```

**Warning**: You must use "andWhere" instead of "Where" statement otherwise column filtering won't work. Same thing about the order and the group (addOrder, addGroup).




## 2. Injecting a custom QueryBuilder
In rare situations, using the callback strategy is not possible because you do not have the full knowledge of how the query should be constructed (e.g. the business logic sits in an external repository/service). 
In this situations, it is possible to use a remote service to create the starting initial QueryBuilder and then inject it into your grid so that the grid can base its operations on top of other business logic generated elsewhere.

```php
<?php
...
$businessQueryBuilder = $myOpaqueRepository->_createDefaultFilteredQueryBuilder();
$source->initQueryBuilder($businessQueryBuilder);

$grid->setSource($source);
...
```

### Method Source::initQueryBuilder parameters

|parameter|Type|Description|
|:--:|:--|:--|:--|:--|
|queryBuilder|Doctrine\ORM\QueryBuilder|(mandatory) The custom QueryBuilder which should be used for data fetching|

**Warning**: Please make sure you absolutely cannot use the callback method to accomplish your goals before using the injector method. In 90% of situations, the callback will lead to a cleaner and safer implementation.
Injecting the QueryBuilder comes with the following risks -
* All OrderBy flags in the injected QueryBuilder will be overridden by the grid during sorting (including default sorting).
* Injecting a complex QueryBuilder can lead to clash of query namespaces/aliases between the original QB and what was added by the grid.

If you are injecting your own QueryBuilder and having problems with the grid, please try removing the injection or using the callback method first as odds are your problem is caused by a complex query which could not be adopted accurately by the grid.
